(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4114],{38913:function(e,n,t){Promise.resolve().then(t.bind(t,17067))},17067:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return f}});var r=t(57437),i=t(2265),l=t(88904);let a=(0,i.forwardRef)((e,n)=>{let[t,l]=(0,i.useState)("i from child");return(0,i.useImperativeHandle)(n,()=>({getChildState:()=>t})),(0,r.jsx)("div",{children:(0,r.jsx)("div",{children:e.data})})});a.displayName="LocationChild";let o=(0,i.forwardRef)((e,n)=>(0,r.jsx)("div",{children:(0,r.jsxs)("div",{ref:n,children:[e.data,"==hahahah"]})}));function s(){let[e,n]=(0,i.useState)(null),t=(0,i.useRef)(null);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("button",{ref:t,onPointerEnter:()=>{var e;console.log(t),t.current;let r=null===(e=t.current)||void 0===e?void 0:e.getBoundingClientRect();n({left:r?r.left:0,top:r?r.top:0,right:r?r.right:0,bottom:r?r.bottom:0})},onPointerLeave:()=>{n(null)},children:"这里是按钮"}),(0,r.jsx)("br",{}),null==e?void 0:e.top,null==e?void 0:e.left,null==e?void 0:e.right,null==e?void 0:e.bottom]})}o.displayName="ForwardChildController";let u=()=>{let e=(0,i.useRef)(null),n=(0,i.useRef)(null);return(0,r.jsxs)("div",{children:[(0,r.jsx)(l.U,{children:'## useImperativeHandle\r\n\r\n获取到子组件内的状态要通过 ref，需要使用 React.forwardRef() 来转发 ref\r\n到子组件，并且要在子组件里使用useImperativeHandle配置返回的ref对象的内容。\r\n这样，子组件就可以将 ref 关联到内部的状态，从而使父组件能够获取到该状态。\r\n\r\n暴露方法给父组件，以便获取子组件内的状态\r\nhttps://react.docschina.org/reference/react/useImperativeHandle\r\n\r\n```\r\nuseImperativeHandle(ref, createHandle, dependencies?) \r\n在组件顶层通过调用 useImperativeHandle 来自定义 ref 暴露出来的句柄：\r\n\r\nexport default function ChildComponent(props: any, ref: any) {\r\n  const [childState, setChildState] = React.useState("Hello from child!");\r\n\r\n  // 暴露方法给父组件，以便获取子组件内的状态\r\n  useImperativeHandle(ref, () => ({\r\n    getChildState: () => childState,\r\n  }));\r\n  return (\r\n    <button onClick={() => setChildState("Updated state")}>Update State</button>\r\n  );\r\n}\r\n```\r\n\r\n### Function 组件不组指定refs 请使用React.forwardRef定义\r\n\r\n        Warning: Function components cannot be given refs. Attempts to access\r\n        this ref will fail. Did you mean to use React.forwardRef()?\r\n\r\n\r\n\r\n# useRef 解析\r\ntypescript 如果传泛型必须指定null\r\nconst childRef = useRef<LocationChildRef>(null);\r\n否则编译不过\r\nhttps://stackoverflow.com/questions/74989176/type-mutablerefobjectundefined-is-not-assignable-to-type-legacyrefhtmldive\r\n\r\n```agsl\r\n    /**\r\n     * `useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\r\n     * (`initialValue`). The returned object will persist for the full lifetime of the component.\r\n     *\r\n     * Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\r\n     * value around similar to how you’d use instance fields in classes.\r\n     *\r\n     * @version 16.8.0\r\n     * @see {@link https://react.dev/reference/react/useRef}\r\n     */\r\n    function useRef<T>(initialValue: T): MutableRefObject<T>;\r\n    // convenience overload for refs given as a ref prop as they typically start with a null value\r\n    /**\r\n     * `useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\r\n     * (`initialValue`). The returned object will persist for the full lifetime of the component.\r\n     *\r\n     * Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\r\n     * value around similar to how you’d use instance fields in classes.\r\n     *\r\n     * Usage note: if you need the result of useRef to be directly mutable, include `| null` in the type\r\n     * of the generic argument.\r\n     *\r\n     * @version 16.8.0\r\n     * @see {@link https://react.dev/reference/react/useRef}\r\n     */\r\n    function useRef<T>(initialValue: T | null): RefObject<T>;\r\n    // convenience overload for potentially undefined initialValue / call with 0 arguments\r\n    // has a default to stop it from defaulting to {} instead\r\n    /**\r\n     * `useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\r\n     * (`initialValue`). The returned object will persist for the full lifetime of the component.\r\n     *\r\n     * Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\r\n     * value around similar to how you’d use instance fields in classes.\r\n     *\r\n     * @version 16.8.0\r\n     * @see {@link https://react.dev/reference/react/useRef}\r\n     */\r\n    function useRef<T = undefined>(): MutableRefObject<T | undefined>;\r\n```\r\n\r\n\r\n\r\n'}),"然后将 controlRef 对象作为 controlRef 属性传递给想要操作的 DOM 节点的 JSX 元素https://stackoverflow.com/questions/74989176/type-mutablerefobjectundefined-is-not-assignable-to-type-legacyrefhtmldive",(0,r.jsx)(a,{ref:e,data:"Hello World"}),(0,r.jsx)(o,{ref:n,data:"i.m from parent"}),(0,r.jsx)("br",{}),(0,r.jsx)(s,{}),(0,r.jsx)("button",{onClick:()=>{e.current&&(console.log(e.current),console.log(e.current.getChildState())),n.current&&console.log(n.current.innerHTML)},children:"Get Child State Debug 后看console"})]})};u.displayName="ParentComponent";var f=u}},function(e){e.O(0,[8904,2971,7023,1744],function(){return e(e.s=38913)}),_N_E=e.O()}]);